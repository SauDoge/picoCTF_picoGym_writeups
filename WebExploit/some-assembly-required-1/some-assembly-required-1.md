# Some Assembly Required 1

## Given
* A URL http://mercury.picoctf.net:37669/index.html

## Process
* The website requires us to enter the flag. Let's try entering some random things first.
    * 1
    * True
    * flag{}
* Enough messing around. Let's check the source then. By looking into the Javascript file, we saw some gibberish.
```Javascript
const _0x402c=['value','2wfTpTR','instantiate','275341bEPcme','innerHTML','1195047NznhZg','1qfevql','input','1699808QuoWhA','Correct!','check_flag','Incorrect!','./JIFxzHyW8W','23SMpAuA','802698XOMSrr','charCodeAt','474547vVoGDO','getElementById','instance','copy_char','43591XxcWUl','504454llVtzW','arrayBuffer','2NIQmVj','result'];const _0x4e0e=function(_0x553839,_0x53c021){_0x553839=_0x553839-0x1d6;let _0x402c6f=_0x402c[_0x553839];return _0x402c6f;};(function(_0x76dd13,_0x3dfcae){const _0x371ac6=_0x4e0e;while(!![]){try{const _0x478583=-parseInt(_0x371ac6(0x1eb))+parseInt(_0x371ac6(0x1ed))+-parseInt(_0x371ac6(0x1db))*-parseInt(_0x371ac6(0x1d9))+-parseInt(_0x371ac6(0x1e2))*-parseInt(_0x371ac6(0x1e3))+-parseInt(_0x371ac6(0x1de))*parseInt(_0x371ac6(0x1e0))+parseInt(_0x371ac6(0x1d8))*parseInt(_0x371ac6(0x1ea))+-parseInt(_0x371ac6(0x1e5));if(_0x478583===_0x3dfcae)break;else _0x76dd13['push'](_0x76dd13['shift']());}catch(_0x41d31a){_0x76dd13['push'](_0x76dd13['shift']());}}}(_0x402c,0x994c3));let exports;(async()=>{const _0x48c3be=_0x4e0e;let _0x5f0229=await fetch(_0x48c3be(0x1e9)),_0x1d99e9=await WebAssembly[_0x48c3be(0x1df)](await _0x5f0229[_0x48c3be(0x1da)]()),_0x1f8628=_0x1d99e9[_0x48c3be(0x1d6)];exports=_0x1f8628['exports'];})();function onButtonPress(){const _0xa80748=_0x4e0e;let _0x3761f8=document['getElementById'](_0xa80748(0x1e4))[_0xa80748(0x1dd)];for(let _0x16c626=0x0;_0x16c626<_0x3761f8['length'];_0x16c626++){exports[_0xa80748(0x1d7)](_0x3761f8[_0xa80748(0x1ec)](_0x16c626),_0x16c626);}exports['copy_char'](0x0,_0x3761f8['length']),exports[_0xa80748(0x1e7)]()==0x1?document[_0xa80748(0x1ee)](_0xa80748(0x1dc))[_0xa80748(0x1e1)]=_0xa80748(0x1e6):document[_0xa80748(0x1ee)](_0xa80748(0x1dc))[_0xa80748(0x1e1)]=_0xa80748(0x1e8);}
```
* It looks like Javascript and Assembly had a baby together. Lets decode this mess. First, let's change all the hex reference to something more meaningful and readable.
```Javascript
const arr = [
  "value", // 0
  "2wfTpTR", // 1
  "instantiate", // 2
  "275341bEPcme", // 3
  "innerHTML", // 4
  "1195047NznhZg", // 5
  "1qfevql", // 6
  "input", // 7
  "1699808QuoWhA", // 8
  "Correct!", // 9
  "check_flag", // 10
  "Incorrect!", // 11
  "./JIFxzHyW8W", // 12
  "23SMpAuA", // 13
  "802698XOMSrr", // 14
  "charCodeAt", // 15
  "474547vVoGDO", // 16
  "getElementById", // 17
  "instance", // 18
  "copy_char", // 19
  "43591XxcWUl", // 20
  "504454llVtzW", // 21
  "arrayBuffer", // 22
  "2NIQmVj", // 23
  "result", // 24
];
const func1 = function (idx, param2) {
  idx = idx - 470; // idx - 470
  let temp = arr[idx];
  return temp;
};

(function (array, some_param) {
  const func1 = func1;
  while (!![]) {
    try {
      const integer =
        -parseInt(func1(491)) +
        parseInt(func1(493)) +
        -parseInt(func1(475)) * -parseInt(func1(473)) +
        -parseInt(func1(482)) * -parseInt(func1(483)) +
        -parseInt(func1(478)) * parseInt(func1(480)) +
        parseInt(func1(472)) * parseInt(func1(490)) +
        -parseInt(func1(485));
      if (integer === some_param) break;
      else array["push"](array["shift"]());
    } catch (_0x41d31a) {
      array["push"](array["shift"]());
    }
  }
})(arr, 627907);

let exports;

(async () => {
  const func1 = func1;
  let _0x5f0229 = await fetch(func1(489)),
    _0x1d99e9 = await WebAssembly[func1(479)](
      await _0x5f0229[func1(474)]()
    ),
    _0x1f8628 = _0x1d99e9[func1(470)];
  exports = _0x1f8628["exports"];
})();

function onButtonPress() {
  const func1_copy = func1;
  let input = document["getElementById"](func1_copy(484))[ // get arr[14]
    func1_copy(477) // get arr[7]
  ];
  for (let counter = 0; counter < input["length"]; counter++) {
    exports[func1_copy(471)](
      // get arr [1]
      input[func1_copy(492)](counter),
      counter
    );
  }
  exports["copy_char"](0, input["length"]),
    exports[func1_copy(487)]() == 1
      ? (document[func1_copy(494)](func1_copy(476))[func1_copy(481)] =
          func1_copy(486))
      : (document[func1_copy(494)](func1_copy(476))[func1_copy(481)] =
          func1_copy(488));
}
```
* Now we can start reading the JS file. The array is first re-arranged. I use `solve.js` to produce the rearranged array. Here are the results
```Javascript
/* re-arranged arr
[
  "instance", // 0
  "copy_char", // 1
  "43591XxcWUl", // 2
  "504454llVtzW", // 3
  "arrayBuffer", // 4
  "2NIQmVj", // 5
  "result", // 6
  "value", // 7
  "2wfTpTR", // 8
  "instantiate", // 9
  "275341bEPcme", // 10
  "innerHTML", // 11
  "1195047NznhZg", // 12
  "1qfevql", // 13
  "input", // 14
  "1699808QuoWhA", // 15
  "Correct!", // 16
  "check_flag", // 17
  "Incorrect!", // 18
  "./JIFxzHyW8W", // 19
  "23SMpAuA", // 20
  "802698XOMSrr", // 21
  "charCodeAt", // 22
  "474547vVoGDO", // 23
  "getElementById", // 24
];
*/ 
```
* In the function `onButtonPress()`, we can see the input is read and check using `export(check_flag)`. But where does that `export(check_flag)` comes from? We can see an async function that takes something from WebAssembly something. [Google Time](https://webassembly.org/).
* So it appears that WebAssembly (wasm) is a language format that can run other languages on web after compiled. You can find the wasm file at 'Inspector' -> 'Debugger' -> 'wasm://'. So the JS is importing the functions from some wasm file like normal Javascript libraries. Let's check the wasm file.

## Solution
* The flag is actually written in plaintext if you scroll to the bottom of the WebAssembly file.

## Flag
> picoCTF{a8bae10f4d9544110222c2d639dc6de6}


